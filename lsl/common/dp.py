# -*- coding: utf-8 -*-

"""
Module that contains common values found in the DP ICD, revision I.  The values 
are:
  * f_S - Sampleng rate in samples per second
  * T - Slot duration in seconds
  * T_2 - Sub-slot duration
  * N_MAX_UDP - Maximum UDP packet size
  
Also included are two functions to convert between frequencies and DP tuning 
words and functions for calculating the magnitude response of the TBN and DRX 
filters.
"""

import numpy
from scipy.signal import freqz
from scipy.interpolate import interp1d


__version__ = '0.4'
__revision__ = '$Rev$'
__all__ = ['fS', 'T', 'T2', 'N_MAX', 'freq2word', 'word2freq', 'tbnFilter', 'drxFilter', '__version__', '__revision__', '__all__']

fS = 196.0e6	# Hz
T = 1.0		# seconds
T2 = 0.010	# seconds
N_MAX = 8192	# bytes


_nPts = 1000 # Number of points to use in calculating the bandpasses

def freq2word(freq):
	"""
	Given a frequency in Hz, convert it to the closest DP tuning word.
	"""
	
	return int(round(freq/fS * 2**32))


def word2freq(word):
	"""
	Given a DP tuning word, convert it to a frequncy in Hz.
	"""
	
	return word*fS / 2**32


def tbnFilter(sampleRate=1e5, Alias=False):
	"""
	Return a function that will generate the shape of a TBN filter for a given sample
	rate.
	"""
	
	decimation = fS / sampleRate / 10
	decimationCIC = decimation / 2
	
	# CIC settings
	N =  2
	R = 98
	
	# FIR coefficients
	tbnFIR = [-2.7370000000000000e+003,  5.3100000000000000e+002,  5.1600000000000000e+002, 
			 5.2100000000000000e+002,  5.4300000000000000e+002,  5.7900000000000000e+002, 
			 6.2500000000000000e+002,  6.7900000000000000e+002,  7.3800000000000000e+002, 
			 7.9800000000000000e+002,  8.5800000000000000e+002,  9.1500000000000000e+002, 
			 9.6600000000000000e+002,  1.0090000000000000e+003,  1.0420000000000000e+003, 
			 1.0620000000000000e+003,  1.0680000000000000e+003,  1.0570000000000000e+003, 
			 1.0280000000000000e+003,  9.8000000000000000e+002,  9.1100000000000000e+002, 
			 8.2000000000000000e+002,  7.1100000000000000e+002,  5.7400000000000000e+002, 
			 4.2100000000000000e+002,  2.4700000000000000e+002,  5.1000000000000000e+001, 
			-1.6300000000000000e+002, -3.9200000000000000e+002, -6.3400000000000000e+002,
			-8.8600000000000000e+002, -1.1450000000000000e+003, -1.4080000000000000e+003, 
			-1.6710000000000000e+003, -1.9300000000000000e+003, -2.1790000000000000e+003, 
			-2.4140000000000000e+003, -2.6290000000000000e+003, -2.8200000000000000e+003,
			-2.9820000000000000e+003, -3.1100000000000000e+003, -3.1990000000000000e+003, 
			-3.2440000000000000e+003, -3.2410000000000000e+003, -3.1860000000000000e+003, 
			-3.0730000000000000e+003, -2.9030000000000000e+003, -2.6710000000000000e+003, 
			-2.3740000000000000e+003, -2.0130000000000000e+003, -1.5850000000000000e+003, 
			-1.0920000000000000e+003, -5.3200000000000000e+002,  9.0000000000000000e+001, 
			 7.7500000000000000e+002,  1.5170000000000000e+003,  2.3140000000000000e+003, 
			 3.1600000000000000e+003,  4.0510000000000000e+003,  4.9800000000000000e+003, 
			 5.9410000000000000e+003,  6.9270000000000000e+003,  7.9290000000000000e+003, 
			 8.9400000000000000e+003,  9.9520000000000000e+003,  1.0955000000000000e+004, 
			 1.1943000000000000e+004,  1.2904000000000000e+004,  1.3831000000000000e+004, 
			 1.4715000000000000e+004,  1.5549000000000000e+004,  1.6323000000000000e+004, 
			 1.7032000000000000e+004,  1.7668000000000000e+004,  1.8225000000000000e+004, 
			 1.8698000000000000e+004,  1.9082000000000000e+004,  1.9373000000000000e+004, 
			 1.9569000000000000e+004,  1.9667000000000000e+004,  1.9667000000000000e+004, 
			 1.9569000000000000e+004,  1.9373000000000000e+004,  1.9082000000000000e+004, 
			 1.8698000000000000e+004,  1.8225000000000000e+004,  1.7668000000000000e+004, 
			 1.7032000000000000e+004,  1.6323000000000000e+004,  1.5549000000000000e+004, 
			 1.4715000000000000e+004,  1.3831000000000000e+004,  1.2904000000000000e+004, 
			 1.1943000000000000e+004,  1.0955000000000000e+004,  9.9520000000000000e+003, 
			 8.9400000000000000e+003,  7.9290000000000000e+003,  6.9270000000000000e+003, 
			 5.9410000000000000e+003,  4.9800000000000000e+003,  4.0510000000000000e+003, 
			 3.1600000000000000e+003,  2.3140000000000000e+003,  1.5170000000000000e+003, 
			 7.7500000000000000e+002,  9.0000000000000000e+001, -5.3200000000000000e+002, 
			-1.0920000000000000e+003, -1.5850000000000000e+003, -2.0130000000000000e+003, 
			-2.3740000000000000e+003, -2.6710000000000000e+003, -2.9030000000000000e+003, 
			-3.0730000000000000e+003, -3.1860000000000000e+003, -3.2410000000000000e+003, 
			-3.2440000000000000e+003, -3.1990000000000000e+003, -3.1100000000000000e+003, 
			-2.9820000000000000e+003, -2.8200000000000000e+003, -2.6290000000000000e+003, 
			-2.4140000000000000e+003, -2.1790000000000000e+003, -1.9300000000000000e+003, 
			-1.6710000000000000e+003, -1.4080000000000000e+003, -1.1450000000000000e+003, 
			-8.8600000000000000e+002, -6.3400000000000000e+002, -3.9200000000000000e+002, 
			-1.6300000000000000e+002,  5.1000000000000000e+001,  2.4700000000000000e+002, 
			 4.2100000000000000e+002,  5.7400000000000000e+002,  7.1100000000000000e+002, 
			 8.2000000000000000e+002,  9.1100000000000000e+002,  9.8000000000000000e+002, 
			 1.0280000000000000e+003,  1.0570000000000000e+003,  1.0680000000000000e+003, 
			 1.0620000000000000e+003,  1.0420000000000000e+003,  1.0090000000000000e+003, 
			 9.6600000000000000e+002,  9.1500000000000000e+002,  8.5800000000000000e+002, 
			 7.9800000000000000e+002,  7.3800000000000000e+002,  6.7900000000000000e+002, 
			 6.2500000000000000e+002,  5.7900000000000000e+002,  5.4300000000000000e+002, 
			 5.2100000000000000e+002,  5.1600000000000000e+002,  5.3100000000000000e+002, 
			-2.7370000000000000e+003]
	
	# Part 1 - CIC filter
	h = numpy.linspace(0, numpy.pi/decimationCIC/2, num=_nPts, endpoint=True)
	wCIC = (numpy.sin(h*R)/numpy.sin(h/2))**N
	wCIC[0] = (2*R)**N
	
	# Part 2 - FIR filter
	h, wFIR = freqz(tbnFIR, 1, _nPts)
	
	# Cascade
	w = numpy.abs(wCIC) * numpy.abs(wFIR)
	
	# Convert to a "real" frequency and magnitude response
	h *= fS / decimation / numpy.pi
	w = numpy.abs(w)**2
	
	# Alias
	if Alias:
		
		aliasWidth = sampleRate / 2.0
		for i in xrange(int(h.max()/aliasWidth)):
			section = numpy.where( (h >= i*aliasWidth) & (h < (i+1)*aliasWidth) )[0]
			sectionStart = section[0]
			sectionStop  = section[-1] + 1
			
			temp = w[sectionStart:sectionStop]
			try:
				if i % 2 == 0:
					outW += temp
				else:
					outW += temp[::-1]
			except:
				outW = temp*1.0
		
		w *= 0
		w += 1
		w[0:len(outW)] = outW
	
	# Mirror
	h = numpy.concatenate([-h[::-1], h[1:]])
	w = numpy.concatenate([ w[::-1], w[1:]])
	
	# Return the interpolating function
	return interp1d(h, w/w.max(), kind='cubic', bounds_error=False)


def drxFilter(sampleRate=19.6e6, Alias=False):
	"""
	Return a function that will generate the shape of a DRX filter for a given sample
	rate.
	
	Based on memo DRX0001.
	"""
	
	decimation = fS / sampleRate
	decimationCIC = decimation / 2
	
	# CIC settings
	N = 5
	R = 5
	
	# FIR coefficients
	drxFIR = [-6.2000000000000000e+001,  6.6000000000000000e+001,  1.4500000000000000e+002, 
			 3.4000000000000000e+001, -1.4400000000000000e+002, -5.9000000000000000e+001, 
			 1.9900000000000000e+002,  1.4500000000000000e+002, -2.2700000000000000e+002, 
			-2.5700000000000000e+002,  2.3200000000000000e+002,  4.0500000000000000e+002, 
			-1.9400000000000000e+002, -5.8300000000000000e+002,  9.2000000000000000e+001, 
			 7.8200000000000000e+002,  9.4000000000000000e+001, -9.9000000000000000e+002, 
			-3.9700000000000000e+002,  1.1860000000000000e+003,  8.5900000000000000e+002, 
			-1.3400000000000000e+003, -1.5650000000000000e+003,  1.3960000000000000e+003, 
			 2.7180000000000000e+003, -1.1870000000000000e+003, -4.9600000000000000e+003, 
			-1.8900000000000000e+002,  1.1431000000000000e+004,  1.7747000000000000e+004, 
			 1.1431000000000000e+004, -1.8900000000000000e+002, -4.9600000000000000e+003, 
			-1.1870000000000000e+003,  2.7180000000000000e+003,  1.3960000000000000e+003, 
			-1.5650000000000000e+003, -1.3400000000000000e+003,  8.5900000000000000e+002, 
			 1.1860000000000000e+003, -3.9700000000000000e+002, -9.9000000000000000e+002,
			 9.4000000000000000e+001,  7.8200000000000000e+002,  9.2000000000000000e+001,
			-5.8300000000000000e+002, -1.9400000000000000e+002,  4.0500000000000000e+002, 
			 2.3200000000000000e+002, -2.5700000000000000e+002, -2.2700000000000000e+002, 
			 1.4500000000000000e+002,  1.9900000000000000e+002, -5.9000000000000000e+001, 
			-1.4400000000000000e+002,  3.4000000000000000e+001,  1.4500000000000000e+002, 
			 6.6000000000000000e+001, -6.2000000000000000e+001]
	     
	# Part 1 - CIC filter
	h = numpy.linspace(0, numpy.pi/decimationCIC/2, num=_nPts, endpoint=True)
	wCIC = (numpy.sin(h*R)/numpy.sin(h/2))**N
	wCIC[0] = (2*R)**N
	
	# Part 2 - FIR filter
	h, wFIR = freqz(drxFIR, 1, _nPts)
	
	# Cascade
	w = numpy.abs(wCIC) * numpy.abs(wFIR)
	
	# Convert to a "real" frequency and magnitude response
	h *= fS / decimation / numpy.pi
	w = numpy.abs(w)**2
	
	# Alias
	if Alias:
		
		aliasWidth = sampleRate / 2.0
		for i in xrange(int(h.max()/aliasWidth)):
			section = numpy.where( (h >= i*aliasWidth) & (h < (i+1)*aliasWidth) )[0]
			sectionStart = section[0]
			sectionStop  = section[-1] + 1
			
			temp = w[sectionStart:sectionStop]
			try:
				if i % 2 == 0:
					outW += temp
				else:
					outW += temp[::-1]
			except:
				outW = temp*1.0
		
		w *= 0
		w += 1
		w[0:len(outW)] = outW
	
	# Mirror
	h = numpy.concatenate([-h[::-1], h[1:]])
	w = numpy.concatenate([w[::-1], w[1:]])
	
	# Return the interpolating function
	return interp1d(h, w/w.max(), kind='cubic', bounds_error=False)
